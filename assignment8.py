# -*- coding: utf-8 -*-
"""Assignment8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_v2E7V0O6r_sIexX8i05MS2y6m-m9vkq
"""

import pandas as pd
import numpy as np
import seaborn as sns

import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split

df = pd.read_csv("uber.csv")

df

df.info()

df.head()

df.isnull()

df.isnull().sum()

df.shape

df.columns

df.drop(columns=["Unnamed: 0", "key"], inplace=True)
df.head()

df

df['dropoff_latitude'].fillna(value=df['dropoff_latitude'].mean(), inplace=True)
df['dropoff_longitude'].fillna(value=df['dropoff_longitude'].median(), inplace=True)

df.dtypes

df.pickup_datetime = pd.to_datetime(df.pickup_datetime)
df.dtypes

df = df.assign(hour = df.pickup_datetime.dt.hour,
               day = df.pickup_datetime.dt.day,
               month = df.pickup_datetime.dt.month,
               year = df.pickup_datetime.dt.year,
               dayofweek = df.pickup_datetime.dt.dayofweek)

df.head

df

df.plot(kind = "box", subplots = True, layout = (6,2), figsize=(15,20))
plt.show()

def remove_outlier(df1, col):
  Q1 = df1[col].quantile(0.25)
  Q3 = df[col].quantile(0.75)

  IQR = Q3 - Q1
  lower_whisker = Q1 - 1.5*IQR
  upper_whisker = Q3 -1.5*IQR

  df[col] = np.clip(df1[col], lower_whisker, upper_whisker)
  return df1

def treat_outliers_all(df1 , col_list):
    for c in col_list:
        df1 = remove_outlier(df , c)
    return df1

df = treat_outliers_all(df , df.iloc[: , 0::])

df.plot(kind = "box",subplots = True,layout = (7,2),figsize=(15,20))
plt.show()

corr = df.corr()
corr

fig,axis = plt.subplots(figsize = (10,6))
sns.heatmap(df.corr(),annot = True)

df_x = df[['pickup_longitude','pickup_latitude','dropoff_longitude','dropoff_latitude','passenger_count','hour','day','month','year','dayofweek']]
df_y = df['fare_amount']

x_train, x_test, y_train, y_test = train_test_split(df_x, df_y, test_size=0.2, random_state=1)

from sklearn.linear_model import LinearRegression

# initialize the linear regression model
reg = LinearRegression()

# Train the model with our training data
reg.fit(x_train, y_train)

y_pred_lin = reg.predict(x_test)
print(y_pred_lin)

from sklearn.ensemble import RandomForestRegressor

#Here n_estimators means number of trees you want to build before making the prediction
rf = RandomForestRegressor(n_estimators=100)
rf.fit(x_train,y_train)

y_pred_rf = rf.predict(x_test)
print(y_pred_rf)

cols = ['Model', 'RMSE', 'R-Squared']

# create a empty dataframe of the colums
# columns: specifies the columns to be selected
result_tabulation = pd.DataFrame(columns = cols)

from sklearn import metrics
from sklearn.metrics import r2_score

reg_RMSE = np.sqrt(metrics.mean_squared_error(y_test, y_pred_lin))
reg_squared = r2_score(y_test, y_pred_lin)

full_metrics = pd.Series({'Model': "Linear Regression", 'RMSE' : reg_RMSE, 'R-Squared' : reg_squared})

# append our result table using append()
# ignore_index=True: does not use the index labels
# python can only append a Series if ignore_index=True or if the Series has a name
result_tabulation = result_tabulation.append(full_metrics, ignore_index = True)

# print the result table
result_tabulation

from sklearn import metrics
from sklearn.metrics import r2_score

reg_RMSE = np.sqrt(metrics.mean_squared_error(y_test, y_pred_lin))
reg_squared = r2_score(y_test, y_pred_lin)

full_metrics = pd.Series({'Model': "Linear Regression", 'RMSE' : reg_RMSE, 'R-Squared' : reg_squared})

# Instead of using append, use pd.concat to add the new row
# This avoids the AttributeError and is more efficient
result_tabulation = pd.concat([result_tabulation, full_metrics.to_frame().T], ignore_index=True)

# print the result table
result_tabulation

rf_RMSE = np.sqrt(metrics.mean_squared_error(y_test, y_pred_rf))
rf_squared = r2_score(y_test, y_pred_rf)


full_metrics = pd.Series({'Model': "Random Forest ", 'RMSE':rf_RMSE, 'R-Squared': rf_squared})
# Instead of using append, use pd.concat to add the new row
# This avoids the AttributeError and is more efficient
result_tabulation = pd.concat([result_tabulation, full_metrics.to_frame().T], ignore_index=True)

# print the result table
result_tabulation

